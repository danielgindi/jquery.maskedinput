{"version":3,"file":"jquery.maskedinput.date.js","sources":["src/jquery.maskedinput.core.js","src/jquery.maskedinput.date.js"],"sourcesContent":["'use strict';\r\n\r\nimport $ from 'jquery';\r\n\r\n/**\r\n * @typedef {String} MaskedInput~PartType\r\n * @name MaskedInput~PartType\r\n * @enum {String}\r\n */\r\nconst PartType = {\r\n    /** @const */ NUMBER: 'number',\r\n    /** @const */ TEXT: 'text',\r\n    /** @const */ LABEL: 'label',\r\n};\r\n\r\n/**\r\n * @typedef {Object} MaskedInput~Part\r\n * @property {MaskedInput~PartType} [type] - Type of the field\r\n * @property {String|undefined} [name] - Name for this field\r\n * @property {String|undefined} [ariaLabel] - An ARIA accessibility label\r\n * @property {String|undefined} [text] - Text for this field if it's a LABEL\r\n * @property {String|undefined} [placeholder] - Placeholder for the field\r\n * @property {Number} [length] - Length of the field\r\n * @property {Number} [maxLength] - Maximum length of the field\r\n * @property {Number|undefined} [numericMin] - Minimum numeric value\r\n * @property {Number|undefined} [numericMax] - Maximum numeric value\r\n * @property {Boolean|undefined} [wholeNumber] - Force the number to be whole? (default `false`)\r\n * @property {RegExp|String|function(value:String)|undefined} [validator] - Validator regex or function\r\n * @property {String[]|undefined} [options] - Options to choose from for textual field\r\n * @property {function(value,part:MaskedInput~Part)|undefined} [postProcess] - Function for post processing a value before retrieving by user\r\n * @property {Boolean|Number|undefined} [padding] - Enable padding in value result (default `true`)\r\n * @property {Boolean|undefined} [required] - Is the field required (default `true`)\r\n * @property {String|undefined} [defaultValue] - Default value, used if field is not `required`\r\n * @property {Boolean|undefined} [forcePlaceholderWidth] - Always consider placeholder's width (default `true`)\r\n */\r\n\r\n/**\r\n * @typedef {Object} MaskedInput~Pattern\r\n * @property {RegExp|String} [pattern] - Pattern to recognize in the format\r\n * @property {MaskedInput~PartType} [type] - Type of the field\r\n * @property {String|undefined} [name] - Name for this field\r\n * @property {String|undefined} [ariaLabel] - An ARIA accessibility label\r\n * @property {String|function(match):String|undefined} [text] - Text for this field if it's a LABEL\r\n * @property {String|function(match):String|undefined} [placeholder] - Placeholder for the field\r\n * @property {Number|function(match):Number} [length] - Length of the field\r\n * @property {Number|function(match):Number} [maxLength] - Maximum length of the field\r\n * @property {Number|function(match):Number|undefined} [numericMin] - Minimum numeric value\r\n * @property {Number|function(match):Number|undefined} [numericMax] - Maximum numeric value\r\n * @property {Boolean|undefined} [wholeNumber] - Force the number to be whole? (default `false`)\r\n * @property {RegExp|String|function(value:String)|undefined} [validator] - Validator regex or function\r\n * @property {String[]|function(match):String[]|undefined} [options] - Options to choose from for textual field\r\n * @property {function(value,part:MaskedInput~Part)|undefined} [postProcess] - Function for post processing a value before retrieving by user\r\n * @property {Boolean|Number|function(match):(Boolean|Number)|undefined} [padding] - Enable padding in value result (default `true`)\r\n * @property {Boolean|function(match):Boolean|undefined} [required] - Is the field required (default `true`)\r\n * @property {String|function(match):String|undefined} [defaultValue] - Default value, used if field is not `required`\r\n * @property {Boolean|function(match):Boolean|undefined} [forcePlaceholderWidth] - Always consider placeholder's width (default `true`)\r\n */\r\n\r\n/**\r\n * @typedef {Object} MaskedInput~Options\r\n * @property {String} [format] - Format to show\r\n * @property {Object<String, MaskedInput~Pattern>} [patterns] - Additional patterns to recognize in the format\r\n */\r\nconst defaults = /** @type {MaskedInput.Options} */ {\r\n    patterns: {},\r\n};\r\n\r\nconst execRegexWithLeftovers = function (regex, input, onMatch, onLeftover) {\r\n\r\n    let match, lastIndex = 0;\r\n    regex.lastIndex = 0;\r\n    while ((match = regex.exec(input))) {\r\n\r\n        // Add skipped raw text\r\n        if (match.index > lastIndex) {\r\n            onLeftover(input.substring(lastIndex, match.index));\r\n        }\r\n\r\n        onMatch(match);\r\n\r\n        lastIndex = regex.lastIndex;\r\n    }\r\n\r\n    // Add remaining text\r\n    if (input.length > lastIndex) {\r\n        onLeftover(input.substring(lastIndex, input.length));\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Get the selection range in an element\r\n * @param {HTMLInputElement} el\r\n * @returns {{begin: Number, end: Number, direction: 'forward'|'backward'|'none'|undefined}}\r\n */\r\nconst getSelectionRange = function (el) {\r\n    let begin, end, direction = 'none';\r\n\r\n    if (el.setSelectionRange) {\r\n\r\n        begin = el.selectionStart;\r\n        end = el.selectionEnd;\r\n        direction = el.selectionDirection;\r\n\r\n    } else if (document.selection && document.selection.createRange) {\r\n\r\n        const range = document.selection.createRange();\r\n        begin = 0 - range.duplicate().moveStart('character', -10000);\r\n        end = begin + range.text.length;\r\n    }\r\n\r\n    return {\r\n        begin : begin,\r\n        end : end,\r\n        direction: direction,\r\n    };\r\n};\r\n\r\n/**\r\n * Set the selection range in an element\r\n * @param {HTMLInputElement} el\r\n * @param {Number|{begin: Number, end: Number, direction: 'forward'|'backward'|'none'|undefined}} begin\r\n * @param {Number?} end\r\n * @param {('forward'|'backward'|'none')?} direction\r\n */\r\nconst setSelectionRange = function (el, begin, end, direction) {\r\n\r\n    if (typeof arguments[1] === 'object' && 'begin' in arguments[1]) {\r\n        begin = arguments[1].begin;\r\n        end = arguments[1].end;\r\n        direction = arguments[1].direction;\r\n    }\r\n\r\n    if (direction === undefined) {\r\n        if (typeof arguments[2] === 'string' &&\r\n            (arguments[2] === 'forward' || arguments[2] === 'backward' || arguments[2] === 'none')) {\r\n            direction = arguments[2];\r\n            end = null;\r\n        }\r\n    }\r\n\r\n    end = end == null ? begin : end;\r\n\r\n    if (el.setSelectionRange) {\r\n        el.setSelectionRange(begin, end, direction);\r\n\r\n    } else {\r\n        if (el.createTextRange) {\r\n            const range = el.createTextRange();\r\n            range.collapse(true);\r\n            range.moveEnd('character', end);\r\n            range.moveStart('character', begin);\r\n            range.select();\r\n        }\r\n    }\r\n\r\n};\r\n\r\nconst repeatChar = function (char, length) {\r\n    let out = '';\r\n    for (let i = 0; i < length; i++) {\r\n        out += char;\r\n    }\r\n    return out;\r\n};\r\n\r\n/**\r\n * @param {String[]} options\r\n * @param {String} term\r\n * @param {Boolean?} closestChoice\r\n * @param {Boolean?} returnFullMatch\r\n * @param {Boolean?} caseSensitive\r\n * @returns {String|undefined}\r\n */\r\nconst findMatchInArray = function (options, term, closestChoice, returnFullMatch, caseSensitive) {\r\n\r\n    let i, option, optionLower;\r\n    const termLower = caseSensitive ? term : term.toLowerCase();\r\n\r\n    if (closestChoice) {\r\n        // Search for a partial option or partial content match, return the longest match found, or `false`\r\n\r\n        let maxMatchLength = 0;\r\n        let maxMatchOption;\r\n        let maxMatchFullOption;\r\n\r\n        for (i = 0; i < options.length; i++) {\r\n            option = options[i];\r\n            optionLower = caseSensitive ? option : option.toLowerCase();\r\n\r\n            for (let clen = Math.min(option.length, 1); clen <= term.length; clen++) {\r\n                if (option.length >= clen &&\r\n                    optionLower.substr(0, clen) === termLower.substr(0, clen)) {\r\n                    if (clen > maxMatchLength) {\r\n                        maxMatchLength = clen;\r\n                        maxMatchOption = option.substr(0, clen);\r\n                        maxMatchFullOption = option;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return returnFullMatch ? maxMatchFullOption : maxMatchOption;\r\n\r\n    } else {\r\n\r\n        // Search for an exact match or option \"starts with\" the content - all case insensitive\r\n        for (i = 0; i < options.length; i++) {\r\n            option = options[i];\r\n            optionLower = caseSensitive ? option : option.toLowerCase();\r\n\r\n            if (option.length >= term.length &&\r\n                optionLower.substr(0, term.length) === termLower)\r\n                return returnFullMatch ? option : true;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Regex escape\r\n * @param {String} str\r\n * @returns {XML|void|string}\r\n */\r\nconst escapeRegExp = function (str) {\r\n    return str.replace(/[-[\\]/{}()*+?.\\\\$|]/g, '\\\\$&');\r\n};\r\n/**\r\n * Search for closest element to a specified point\r\n * @param {HTMLElement[]} elements\r\n * @param {{left: Number, top: Number }} offset\r\n * @returns {HTMLElement|null}\r\n */\r\nconst closestToOffset = function (elements, offset) {\r\n    const x = offset.left,\r\n        y = offset.top;\r\n    let bestMatch = null,\r\n        minDistance = null;\r\n\r\n    for (let i = 0; i < elements.length; i++) {\r\n        const el = elements[i], $el = $(el);\r\n        const elOffset = $el.offset();\r\n\r\n        elOffset.right = elOffset.left + $el.outerWidth();\r\n        elOffset.bottom = elOffset.top + $el.outerHeight();\r\n\r\n        if (\r\n            (x >= elOffset.left) && (x <= elOffset.right) &&\r\n            (y >= elOffset.top) && (y <= elOffset.bottom)\r\n        ) {\r\n            return el;\r\n        }\r\n\r\n        const offsets = [\r\n            [elOffset.left, elOffset.top],\r\n            [elOffset.right, elOffset.top],\r\n            [elOffset.left, elOffset.bottom],\r\n            [elOffset.right, elOffset.bottom],\r\n        ];\r\n\r\n        for (let o = 0; o < 4; o++) {\r\n            const offset = offsets[o];\r\n            const dx = offset[0] - x;\r\n            const dy = offset[1] - y;\r\n            const distance = Math.sqrt((dx * dx) + (dy * dy));\r\n\r\n            if (minDistance == null || distance < minDistance) {\r\n                minDistance = distance;\r\n                bestMatch = el;\r\n            }\r\n        }\r\n    }\r\n\r\n    return bestMatch;\r\n};\r\n\r\nconst callFunctor = function (functor, bind, _arg1) {\r\n    return (typeof functor === 'function') ?\r\n        functor.apply(bind, Array.prototype.slice.call(arguments, 2)) :\r\n        functor;\r\n};\r\n\r\nconst inputBackbufferCssProps = [\r\n    'font-family',\r\n    'font-size',\r\n    'font-weight',\r\n    'font-size',\r\n    'letter-spacing',\r\n    'text-transform',\r\n    'word-spacing',\r\n    'text-indent',\r\n    'box-sizing',\r\n    'padding-left',\r\n    'padding-right',\r\n];\r\n\r\nconst hasComputedStyle = document.defaultView && document.defaultView.getComputedStyle;\r\n\r\n/**\r\n * Gets the precise content width for an element, with fractions\r\n * @param {Element} el\r\n * @returns {Number}\r\n */\r\nconst getPreciseContentWidth = function (el) {\r\n\r\n    const style = hasComputedStyle ? document.defaultView.getComputedStyle(el) : el.currentStyle;\r\n    let width = parseFloat(style['width']) || 0;\r\n\r\n    if (style['boxSizing'] === 'border-box') {\r\n        width -= parseFloat(style['paddingLeft']) || 0;\r\n        width -= parseFloat(style['paddingRight']) || 0;\r\n        width -= parseFloat(style['borderLeftWidth']) || 0;\r\n        width -= parseFloat(style['borderRightWidth']) || 0;\r\n\r\n        if (width < 0) {\r\n            width = 0;\r\n        }\r\n    }\r\n\r\n    return width;\r\n};\r\n\r\nconst FOCUSABLES = [\r\n    'a[href]',\r\n    'area[href]',\r\n    'input:not([disabled])',\r\n    'select:not([disabled])',\r\n    'textarea:not([disabled])',\r\n    'button:not([disabled])',\r\n    'iframe',\r\n    'object',\r\n    'embed',\r\n    '*[tabindex]',\r\n    '*[contenteditable]',\r\n];\r\n\r\nconst FOCUSABLE_SELECTOR = FOCUSABLES.join(',');\r\nconst TABBABLE_SELECTOR = FOCUSABLES.map(x => x + ':not([tabindex=-1])').join(',');\r\n\r\nconst KEY_ENTER = 13;\r\nconst KEY_ARROW_UP = 38;\r\nconst KEY_ARROW_DOWN = 40;\r\nconst KEY_ARROW_LEFT = 37;\r\nconst KEY_ARROW_RIGHT = 39;\r\n\r\n/** @class MaskedInput */\r\nclass MaskedInput {\r\n    /**\r\n     * @param {MaskedInput.Options?} options\r\n     * @returns {MaskedInput}\r\n     */\r\n    constructor(options) {\r\n        /** @private */\r\n        const o = this.o = $.extend({}, MaskedInput.defaults, options);\r\n\r\n        let patterns = {};\r\n        MaskedInput.patternAddons.forEach(addon => {\r\n            patterns = $.extend(patterns, addon);\r\n        });\r\n        patterns = $.extend(patterns, o.patterns);\r\n        o.patterns = patterns;\r\n\r\n        /** This is for encapsulating private data */\r\n        const p = this.p = {};\r\n\r\n        p.enabled = true;\r\n        p.inputs = [];\r\n\r\n        /** @public */\r\n        const $el = this.$el = $('<div>').addClass(o.className || 'masked-input');\r\n\r\n        /** @public */\r\n        this.el = this.$el[0];\r\n\r\n        // Set control data\r\n        $el\r\n            .data('control', this)\r\n            .data('maskedinput', this);\r\n\r\n        // Parse format\r\n        p.parsed = this._parseFormat(o.format);\r\n\r\n        // Create backbuffer for input\r\n        p.$inputBackBuffer = $('<span aria-hidden=\"true\" style=\"position:absolute;z-index:-1;left:0;top:-9999px;white-space:pre;\"/>');\r\n\r\n        // Hook up click event\r\n        $el.on('click', event => {\r\n            if (event.target !== event.currentTarget &&\r\n                $(event.target).is(FOCUSABLE_SELECTOR)) return;\r\n\r\n            const offset = $(event.currentTarget).offset();\r\n            offset.left += event.offsetX;\r\n            offset.top += event.offsetY;\r\n\r\n            const el = closestToOffset($el.children(FOCUSABLE_SELECTOR), offset);\r\n\r\n            if (el) {\r\n                el.focus();\r\n            }\r\n        });\r\n\r\n        this.render();\r\n\r\n        setTimeout(() => {\r\n            if (this.el && this.el.parentNode) {\r\n                this.resize();\r\n            }\r\n        }, 0);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @param format\r\n     * @returns {MaskedInput~Part[]}\r\n     */\r\n    _parseFormat(format) {\r\n        const o = this.o;\r\n\r\n        let parsedFormat = [];\r\n\r\n        // Loop through basic format matches\r\n\r\n        execRegexWithLeftovers(FORMAT_REGEX, format, (function onMatch(match) {\r\n\r\n            const numericMatch = match[1] || match[2];\r\n            const textMatch = match[3];\r\n            const quotedMatch = match[4];\r\n\r\n            let i, part;\r\n\r\n            if (numericMatch) {\r\n                part = { type: PartType.NUMBER };\r\n                i = numericMatch.indexOf(':');\r\n\r\n                if (i > -1) {\r\n                    part.length = i;\r\n                    part.name = numericMatch.substr(i + 1);\r\n                } else {\r\n                    part.length = numericMatch.length;\r\n                }\r\n\r\n                if (match[2]) { // max length\r\n                    part.maxLength = part.length;\r\n                    part.length = 0;\r\n                }\r\n\r\n                parsedFormat.push(part);\r\n            } else if (textMatch) {\r\n                part = { type: PartType.TEXT };\r\n                if (textMatch[0] === '*') {\r\n                    part.length = 0;\r\n                } else {\r\n                    i = textMatch.indexOf(':');\r\n\r\n                    if (i > -1) {\r\n                        part.length = i;\r\n                        part.name = textMatch.substr(i + 1);\r\n                    } else {\r\n                        part.length = textMatch.length;\r\n                    }\r\n                }\r\n                parsedFormat.push(part);\r\n            } else if (quotedMatch) {\r\n                const labelText = quotedMatch.substr(1, quotedMatch.length - 2);\r\n                part = {\r\n                    type: PartType.LABEL,\r\n                    text: labelText,\r\n                    length: labelText.length,\r\n                };\r\n                parsedFormat.push(part);\r\n            }\r\n\r\n        }).bind(this), (function onLeftover(leftover) {\r\n\r\n            const leftoverParts = [];\r\n\r\n            const part = {\r\n                type: PartType.LABEL,\r\n                text: leftover,\r\n                length: leftover.length,\r\n            };\r\n            leftoverParts.push(part);\r\n\r\n            Object.keys(o.patterns).forEach(key => {\r\n                const patterns = o.patterns[key];\r\n\r\n                const regex = new RegExp(\r\n                    patterns.pattern instanceof RegExp ?\r\n                        patterns.pattern.source :\r\n                        patterns.pattern,\r\n                    patterns.pattern instanceof RegExp ?\r\n                        (patterns.pattern.flags + (patterns.pattern.flags.indexOf('g') > -1 ? '' : 'g')) :\r\n                        'g',\r\n                );\r\n\r\n                for (let fpos = 0; fpos < leftoverParts.length; fpos++) {\r\n                    const fpart = leftoverParts[fpos];\r\n                    if (fpart.type !== PartType.LABEL) continue;\r\n\r\n                    const newParts = [];\r\n\r\n                    execRegexWithLeftovers(regex, fpart.text, (function onMatch(match) {\r\n\r\n                        let validator;\r\n                        if (patterns.validator instanceof RegExp || typeof patterns.validator === 'function') {\r\n                            validator = patterns.validator;\r\n                        } else if (typeof patterns.validator === 'string') {\r\n                            try {\r\n                                validator = new RegExp(patterns.validator);\r\n                            } catch (ignored) { /* nothing to do */ }\r\n                        }\r\n\r\n                        // Translate the part\r\n                        const part = {\r\n                            type: callFunctor(patterns.type, this, match[0]),\r\n                            name: callFunctor(patterns.name, this, match[0]),\r\n                            ariaLabel: callFunctor(patterns.ariaLabel, this, match[0]),\r\n                            text: callFunctor(patterns.text, this, match[0]),\r\n                            placeholder: callFunctor(patterns.placeholder, this, match[0]),\r\n                            length: callFunctor(patterns.length, this, match[0]) || 0,\r\n                            maxLength: callFunctor(patterns.maxLength, this, match[0]) || 0,\r\n                            numericMin: callFunctor(patterns.numericMin, this, match[0]),\r\n                            numericMax: callFunctor(patterns.numericMax, this, match[0]),\r\n                            wholeNumber: callFunctor(patterns.wholeNumber, this, match[0]),\r\n                            validator: validator,\r\n                            options: callFunctor(patterns.options, this, match[0]),\r\n                            postProcess: patterns.postProcess,\r\n                            padding: callFunctor(patterns.padding, this, match[0]),\r\n                            required: callFunctor(patterns.required, this, match[0]),\r\n                            defaultValue: callFunctor(patterns.defaultValue, this, match[0]),\r\n                            forcePlaceholderWidth: callFunctor(patterns.forcePlaceholderWidth, this, match[0]),\r\n                        };\r\n                        //noinspection JSReferencingMutableVariableFromClosure\r\n                        newParts.push(part);\r\n\r\n                    }).bind(this), (function onLeftover(leftover) {\r\n                        const part = {\r\n                            type: PartType.LABEL,\r\n                            text: leftover,\r\n                            length: leftover.length,\r\n                        };\r\n                        //noinspection JSReferencingMutableVariableFromClosure\r\n                        newParts.push(part);\r\n                    }).bind(this));\r\n\r\n                    // Replace old label with new parts\r\n                    Array.prototype.splice.apply(leftoverParts, [fpos, 1].concat(newParts));\r\n\r\n                    // Move leftoverParts position as necessary\r\n                    fpos += newParts.length - 1;\r\n                }\r\n\r\n            });\r\n\r\n            parsedFormat = parsedFormat.concat(leftoverParts);\r\n        }).bind(this));\r\n\r\n        return parsedFormat;\r\n    }\r\n\r\n    render() {\r\n        const p = this.p;\r\n\r\n        this.$el.empty();\r\n\r\n        const inputs = [];\r\n\r\n        p.parsed.forEach(part => {\r\n            if (part.type === PartType.LABEL) {\r\n                const $el = this._renderText(part).appendTo(this.$el);\r\n                part.$el = $el;\r\n                part.el = $el[0];\r\n                return;\r\n            }\r\n\r\n            const $input = this._renderInput(part).appendTo(this.$el);\r\n\r\n            part.$el = $input;\r\n            part.el = $input[0];\r\n\r\n            inputs.push($input);\r\n\r\n            if (part.name && parseInt(part.name, 10).toString() !== part.name) {\r\n                inputs[part.name] = (inputs[part.name] || []).concat(part.el);\r\n            }\r\n        });\r\n\r\n        p.inputs = inputs;\r\n\r\n        this.resize();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @param {MaskedInput~Part} part\r\n     * @param {HTMLInputElement?} input\r\n     * @returns {jQuery}\r\n     */\r\n    _renderInput(part, input) {\r\n        const p = this.p;\r\n\r\n        const isNewInput = !input;\r\n\r\n        let $input;\r\n\r\n        if (isNewInput) {\r\n            $input = $('<input>').data('part', part).prop('disabled', !p.enabled);\r\n            input = $input[0];\r\n        } else {\r\n            $input = $(input);\r\n        }\r\n\r\n        if (part.name) {\r\n            input.setAttribute('data-name', part.name);\r\n        } else {\r\n            input.removeAttribute('data-name');\r\n        }\r\n\r\n        if (part.ariaLabel) {\r\n            input.setAttribute('aria-label', part.ariaLabel);\r\n        } else {\r\n            input.removeAttribute('aria-label');\r\n        }\r\n\r\n        if (part.length || part.maxLength || typeof part.placeholder === 'string') {\r\n            //noinspection UnnecessaryLocalVariableJS\r\n            const placeholder = typeof part.placeholder === 'string'\r\n                ? part.placeholder\r\n                : (part.placeholder === undefined || part.placeholder) ? repeatChar('_', part.length || part.maxLength) : '';\r\n            input.placeholder = placeholder;\r\n        }\r\n\r\n        if (isNewInput) {\r\n            $input\r\n                .on('input.maskedinput', event => {\r\n                    this._handleInput(event, input, part);\r\n                    this._syncInputSizeForPart(part);\r\n                })\r\n                .on('keydown.maskedinput', event => {\r\n                    this._handleKeydown(event, input, part);\r\n                })\r\n                .on('keypress.maskedinput', event => {\r\n                    this._handleKeypress(event, input, part);\r\n                });\r\n        }\r\n\r\n        return $input;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @param {MaskedInput~Part} part\r\n     * @returns {jQuery}\r\n     */\r\n    _renderText(part) {\r\n        return $('<span style=\"white-space: pre\">').text(part.text);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @param {jQuery|Element|String} input\r\n     * @param {Boolean=true} alwaysConsiderPlaceholder\r\n     * @param {String=A} fallbackText\r\n     * @returns {MaskedInput}\r\n     */\r\n    _syncInputSize(input, alwaysConsiderPlaceholder, fallbackText) {\r\n        const p = this.p;\r\n\r\n        if (alwaysConsiderPlaceholder === undefined) {\r\n            alwaysConsiderPlaceholder = true;\r\n        }\r\n\r\n        if (fallbackText === undefined) {\r\n            fallbackText = 'A';\r\n        }\r\n\r\n        const $input = $(input), $backBuffer = p.$inputBackBuffer;\r\n\r\n        /** @type {HTMLInputElement} */\r\n        const inputEl = $input[0];\r\n\r\n        fallbackText = fallbackText == null ? '' : (fallbackText + '');\r\n        const value = inputEl.value || inputEl.placeholder || fallbackText;\r\n\r\n        // Introduce backbuffer to DOM\r\n        $backBuffer\r\n            .css($input.css(inputBackbufferCssProps))\r\n            .text(value)\r\n            .appendTo(this.$el);\r\n\r\n        // Measure these\r\n        let backBufferWidth = getPreciseContentWidth($backBuffer[0]) + 1 /* caret width */;\r\n        const currentWidth = getPreciseContentWidth(inputEl);\r\n\r\n        if (alwaysConsiderPlaceholder &&\r\n            inputEl.value &&\r\n            inputEl.placeholder &&\r\n            inputEl.placeholder !== inputEl.value) {\r\n            $backBuffer.text(inputEl.placeholder);\r\n            backBufferWidth = Math.max(\r\n                backBufferWidth,\r\n                getPreciseContentWidth($backBuffer[0]) + 1, /* caret width */\r\n            );\r\n        }\r\n\r\n        // Compare\r\n        if (backBufferWidth !== currentWidth) {\r\n            // Update if needed\r\n            $input.css('width', backBufferWidth + 'px');\r\n        }\r\n\r\n        if ($input[0].scrollWidth > backBufferWidth) {\r\n            $input.css('width', inputEl.scrollWidth);\r\n        }\r\n\r\n        // Remove backbuffer from DOM\r\n        $backBuffer.remove();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @param {MaskedInput~Part} part\r\n     * @returns {MaskedInput}\r\n     */\r\n    _syncInputSizeForPart(part) {\r\n        if (!part.el || part.type === PartType.LABEL) return this;\r\n        return this._syncInputSize(\r\n            part.el,\r\n            part.forcePlaceholderWidth === undefined ? true : !!part.forcePlaceholderWidth,\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @param {jQuery.Event} event\r\n     * @param {HTMLInputElement} input\r\n     * @param {MaskedInput~Part} part\r\n     * @returns {MaskedInput}\r\n     */\r\n    _handleInput(event, input, part) {\r\n        const content = input.value;\r\n        let validatedContent;\r\n\r\n        // Update input if acceptable\r\n        validatedContent = this._validateContent(content, part);\r\n\r\n        if (validatedContent === false) {\r\n            event.preventDefault();\r\n\r\n            // Fire change event\r\n            this.$el.trigger('change');\r\n\r\n            return this;\r\n        }\r\n\r\n        if (typeof validatedContent === 'string' &&\r\n            content !== validatedContent) {\r\n            input.value = validatedContent;\r\n        }\r\n\r\n        this._syncInputSizeForPart(part);\r\n\r\n        if (this._shouldMoveToNextFieldAfterInput(getSelectionRange(input), input.value, part)) {\r\n            $(input).nextAll(TABBABLE_SELECTOR).first().focus();\r\n        }\r\n\r\n        // Fire change event\r\n        this.$el.trigger('change');\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @param {jQuery.Event} event\r\n     * @param {HTMLInputElement} input\r\n     * @param {MaskedInput~Part} part\r\n     * @returns {MaskedInput}\r\n     */\r\n    _handleKeydown(event, input, part) {\r\n        if (input.readOnly) return this;\r\n\r\n        const keycode = event.which;\r\n        let triggerChange = false;\r\n\r\n        const contentBefore = input.value;\r\n        let validatedContent;\r\n\r\n        // Handle UP/DOWN arrows for next/previous value\r\n\r\n        if (keycode === KEY_ARROW_UP || keycode === KEY_ARROW_DOWN) {\r\n\r\n            let nextValue, tryToUpdate = false;\r\n\r\n            const minLen = part.maxLength ?\r\n                Math.max(1, Math.min(part.length || 0, part.maxLength || 1)) :\r\n                (part.length || 1);\r\n            const maxLen = Math.max(part.length || 0, part.maxLength || 0);\r\n\r\n            if (part.type === PartType.TEXT && part.options) {\r\n\r\n                const fullMatch = findMatchInArray(part.options, contentBefore, true, true, false);\r\n                let index = part.options.indexOf(fullMatch);\r\n\r\n                if (index === -1) {\r\n                    if (keycode === KEY_ARROW_UP) {\r\n                        index = 0;\r\n                    } else {\r\n                        index = part.options.length - 1;\r\n                    }\r\n                } else {\r\n                    index += keycode === KEY_ARROW_DOWN ? 1 : -1;\r\n                }\r\n\r\n                if (index === part.options.length) {\r\n                    index = 0;\r\n                } else if (index === -1) {\r\n                    index = part.options.length - 1;\r\n                }\r\n\r\n                nextValue = part.options[index];\r\n\r\n                tryToUpdate = true;\r\n\r\n            } else if (part.type === PartType.NUMBER) {\r\n\r\n                if (!contentBefore &&\r\n                    keycode === KEY_ARROW_DOWN &&\r\n                    part.wholeNumber &&\r\n                    (typeof part.numericMax === 'number' || maxLen > 0) &&\r\n                    typeof part.numericMin === 'number' &&\r\n                    part.numericMin >= 0) {\r\n\r\n                    // Start with largest number if going down from nothing\r\n                    nextValue = typeof part.numericMax === 'number' ?\r\n                        part.numericMax :\r\n                        parseInt(repeatChar('9', maxLen), 10);\r\n\r\n                } else if (!contentBefore &&\r\n                    keycode === KEY_ARROW_UP &&\r\n                    part.wholeNumber &&\r\n                    typeof part.numericMin === 'number') {\r\n\r\n                    // Start with minimum number\r\n                    nextValue = part.numericMin === 0 ? 1 : part.numericMin;\r\n\r\n                } else {\r\n                    /// Up or down\r\n                    nextValue = parseFloat(contentBefore) || 0;\r\n                    nextValue += keycode === KEY_ARROW_UP ? 1 : -1;\r\n                }\r\n\r\n                // Limit to whole numbers\r\n                if (part.wholeNumber) {\r\n                    nextValue = Math.round(nextValue);\r\n                }\r\n\r\n                // Limit to min/max\r\n                if (typeof part.numericMin === 'number' || typeof part.numericMax === 'number') {\r\n                    nextValue = Math.max(\r\n                        Math.min(\r\n                            nextValue,\r\n                            typeof part.numericMax === 'number' ? part.numericMax : Infinity,\r\n                        ),\r\n                        typeof part.numericMin === 'number' ? part.numericMin : -Infinity,\r\n                    );\r\n                }\r\n\r\n                nextValue = nextValue + '';\r\n\r\n                // Left-pad with zeroes when we figure out that we want that\r\n                if (typeof part.numericMin === 'number' &&\r\n                    part.numericMin >= 0) {\r\n                    nextValue = repeatChar('0', minLen - nextValue.length) + nextValue;\r\n                }\r\n\r\n                tryToUpdate = true;\r\n            }\r\n\r\n            // Update input if acceptable\r\n            if (tryToUpdate && nextValue !== contentBefore) {\r\n                validatedContent = this._validateContent(nextValue, part);\r\n                if (validatedContent === true) {\r\n                    validatedContent = nextValue;\r\n                }\r\n                if (validatedContent !== false) {\r\n                    input.value = validatedContent;\r\n                    this._syncInputSizeForPart(part);\r\n                    event.preventDefault();\r\n\r\n                    triggerChange = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (triggerChange) {\r\n            // Fire change event\r\n            this.$el.trigger('change');\r\n        }\r\n\r\n        // Handle LEFT/RIGHT arrows, basically when we are at the end/beginning of an input\r\n        if (keycode === KEY_ARROW_LEFT || keycode === KEY_ARROW_RIGHT) {\r\n            const isRtl = $(input).css('direction') === 'rtl';\r\n\r\n            if ((!isRtl && keycode === KEY_ARROW_LEFT) || (isRtl && keycode === KEY_ARROW_RIGHT)) {\r\n                if (getSelectionRange(input).begin === 0) {\r\n                    $(input).prevAll(TABBABLE_SELECTOR).first().focus();\r\n                }\r\n            } else {\r\n                if (getSelectionRange(input).begin === input.value.length) {\r\n                    $(input).nextAll(TABBABLE_SELECTOR).first().focus();\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @param {jQuery.Event} event\r\n     * @param {HTMLInputElement} input\r\n     * @param {MaskedInput~Part} part\r\n     * @returns {MaskedInput}\r\n     */\r\n    _handleKeypress(event, input, part) {\r\n        if (input.readOnly) return this;\r\n\r\n        const keycode = event.which;\r\n        const pos = getSelectionRange(input);\r\n\r\n        if (event.ctrlKey || event.altKey || event.metaKey ||\r\n            !keycode ||\r\n            keycode < 32 || keycode === KEY_ENTER) return this; // Not a character, perform default\r\n\r\n        event.preventDefault();\r\n\r\n        let triggerChange = false;\r\n        let moveToNextField = false;\r\n\r\n        const pressedChar = event.key || String.fromCharCode(keycode);\r\n\r\n        const contentBefore = input.value;\r\n        let contentAfter = contentBefore.substr(0, pos.begin) +\r\n            pressedChar +\r\n            contentBefore.substr(pos.end);\r\n\r\n        const validatedContent = this._validateContent(contentAfter, part);\r\n        if (validatedContent === false) return this; // Not validated, ignore keypress\r\n\r\n        if (typeof validatedContent === 'string') {\r\n            contentAfter = validatedContent;\r\n        }\r\n\r\n        if (contentAfter !== contentBefore || contentAfter.substr(pos.begin, 1) === pressedChar) {\r\n\r\n            const newPos = {};\r\n\r\n            // Set caret at new position\r\n\r\n            if (pos.end - pos.begin > 0 && pos.direction === 'backward') {\r\n                newPos.begin = newPos.end = pos.begin;\r\n            } else {\r\n                newPos.begin = newPos.end = pos.begin + 1;\r\n            }\r\n\r\n            // Show rest of only choice found\r\n            if (part.type === PartType.TEXT && part.options) {\r\n\r\n                const fullMatch = findMatchInArray(part.options, contentAfter, false, true, false);\r\n                if (fullMatch !== undefined && fullMatch.length !== contentAfter.length) {\r\n                    // Choose a selection range for the rest of the match\r\n                    newPos.begin = contentAfter.length;\r\n                    newPos.end = fullMatch.length;\r\n\r\n                    // Set new input to full match\r\n                    contentAfter = fullMatch;\r\n                }\r\n\r\n            }\r\n\r\n            // Update value\r\n            input.value = contentAfter;\r\n\r\n            // Update selection / caret\r\n            //noinspection JSCheckFunctionSignatures\r\n            setSelectionRange(input, newPos);\r\n\r\n            // See if we need to move on to next field\r\n            moveToNextField = this._shouldMoveToNextFieldAfterInput(newPos, contentAfter, part);\r\n\r\n            triggerChange = true;\r\n\r\n        } else {\r\n\r\n            // These are usually used as separators\r\n            if (pressedChar === '/' ||\r\n                pressedChar === ':' ||\r\n                pressedChar === '-' ||\r\n                pressedChar === '(' ||\r\n                pressedChar === ')' ||\r\n                pressedChar === '.') {\r\n                moveToNextField = true;\r\n            }\r\n        }\r\n\r\n        this._syncInputSizeForPart(part);\r\n\r\n        if (triggerChange) {\r\n            // Fire change event\r\n            this.$el.trigger('change');\r\n        }\r\n\r\n        if (moveToNextField) {\r\n            $(input).nextAll(TABBABLE_SELECTOR).first().focus();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Determines if we need to skip to next field after input change\r\n     * @private\r\n     * @param {{begin: Number, end: Number}} newPos\r\n     * @param {String} newContent\r\n     * @param {MaskedInput~Part} part\r\n     */\r\n    _shouldMoveToNextFieldAfterInput(newPos, newContent, part) {\r\n        if (newPos.begin === newContent.length) {\r\n            if (part.type === PartType.TEXT) {\r\n                return findMatchInArray(part.options, newContent, false, true, false) === newContent;\r\n            } else {\r\n                return (part.length || part.maxLength || 0) > 0 &&\r\n                    newContent.length === (part.length || part.maxLength);\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     * @param {String} content\r\n     * @param {MaskedInput~Part} part\r\n     * @returns {String|Boolean}\r\n     */\r\n    _validateContent(content, part) {\r\n\r\n        // Priority given to validator\r\n        if (part.validator) {\r\n            if (part.validator instanceof RegExp) {\r\n                return part.validator.test(content);\r\n            }\r\n\r\n            let ret = part.validator.call(this, content, part);\r\n            if (ret == null) {\r\n                ret = false;\r\n            }\r\n            return ret;\r\n        }\r\n\r\n        const maxLen = Math.max(part.length || 0, part.maxLength || 0);\r\n\r\n        // Test numeric\r\n        if (part.type === PartType.NUMBER) {\r\n\r\n            if (part.wholeNumber) {\r\n                content = content.replace(/[^-0-9]/g, ''); // Zeroes and \"-\" only\r\n            } else {\r\n                content = content.replace(/[^-0-9.]/g, ''); // Zeroes, \"-\" and \".\" only\r\n            }\r\n\r\n            content = content\r\n                .replace(/^.+-/g, '-') // Dash can only be at the beginning\r\n                .replace(/\\..*\\./g, '.'); // Only one decimal point\r\n\r\n            if (maxLen > 0 && content.length > maxLen) {\r\n                content = content.substr(0, maxLen);\r\n            }\r\n\r\n            // Limit to min/max\r\n            // It's important to do this AFTER trimming the value,\r\n            // To allow inserting character in the middle.\r\n            if (typeof part.numericMin === 'number' || typeof part.numericMax === 'number') {\r\n                let parsedValue = parseFloat(content);\r\n                if (!isNaN(parsedValue)) {\r\n                    parsedValue = Math.max(\r\n                        Math.min(\r\n                            parsedValue,\r\n                            typeof part.numericMax === 'number' ? part.numericMax : Infinity,\r\n                        ),\r\n                        typeof part.numericMin === 'number' ? part.numericMin : -Infinity,\r\n                    );\r\n\r\n                    if (parsedValue !== parseFloat(content)) {\r\n                        content = parsedValue + '';\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!content) {\r\n                return false;\r\n            }\r\n\r\n            return content;\r\n        }\r\n\r\n        // Test textual\r\n        if (part.type === PartType.TEXT) {\r\n            if (part.options) {\r\n                const match = findMatchInArray(part.options, content, true, false, false);\r\n                if (match !== undefined) {\r\n                    return match;\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return maxLen === 0 || content.length <= maxLen;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns {MaskedInput}\r\n     */\r\n    resize() {\r\n        const p = this.p;\r\n\r\n        (p.parsed || []).forEach(part => this._syncInputSizeForPart(part));\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Retrieve a field element by index or label\r\n     * @public\r\n     * @param {Number|String} index\r\n     * @returns {HTMLInputElement}\r\n     */\r\n    field(index) {\r\n        const p = this.p;\r\n\r\n        const input = p.inputs[index];\r\n\r\n        if (!input) return undefined;\r\n\r\n        return $.isArray(input) ? input.slice(0) : input;\r\n    }\r\n\r\n    /**\r\n     * Creates a pattern for parsing an incoming value\r\n     * @private\r\n     * @returns {string}\r\n     */\r\n    _valuePattern() {\r\n        const p = this.p;\r\n\r\n        let pattern = '';\r\n\r\n        p.parsed.forEach(part => {\r\n            let group = '';\r\n\r\n            const minLen = part.maxLength ?\r\n                Math.max(1, Math.min(part.length || 0, part.maxLength || 1)) :\r\n                (part.length || 1);\r\n            const maxLen = Math.max(part.length || 0, part.maxLength || 0);\r\n\r\n            if (part.type === PartType.TEXT) {\r\n                if (part.options) {\r\n                    for (let i = 0; i < part.options.length; i++) {\r\n                        if (i > 0) {\r\n                            group += '|';\r\n                        }\r\n                        group += escapeRegExp(part.options[i]);\r\n                    }\r\n                } else {\r\n                    if (maxLen) {\r\n                        group += '.{0,' + maxLen + '}';\r\n                    } else {\r\n                        group += '.*?';\r\n                    }\r\n                }\r\n            } else if (part.type === PartType.NUMBER) {\r\n                if (part.wholeNumber) {\r\n                    if (part.length > 0) {\r\n                        group += '[-+]' + '[0-9]{' + (minLen - 1) + ',' + (maxLen - 1) + '}';\r\n                        group += '|[0-9]{' + minLen + ',' + maxLen + '}';\r\n                    } else {\r\n                        group += '[-+]?[0-9]+';\r\n                    }\r\n                } else {\r\n                    if (maxLen) {\r\n                        group += '[-+]' + '[0-9.]{' + (minLen - 1) + ',' + (maxLen - 1) + '}';\r\n                        group += '|[0-9.]{' + minLen + ',' + maxLen + '}';\r\n                    } else {\r\n                        group += '[-+]?(?:[0-9]+(?:\\\\.[0-9]+)?|\\\\.[0-9]+)';\r\n                    }\r\n                }\r\n            } else /* if (part.type === PartType.LABEL) */ {\r\n                group += escapeRegExp(part.text == null ? '' : (part.text + ''));\r\n            }\r\n\r\n            pattern += '(' + group + ')';\r\n\r\n            if (part.required !== undefined && !part.required) {\r\n                pattern += '?';\r\n            }\r\n        });\r\n\r\n        return '^' + pattern + '$';\r\n    }\r\n\r\n    /**\r\n     * Retrieve or set an input element's value\r\n     * @private\r\n     * @param {HTMLInputElement|jQuery|String} input\r\n     * @param {String?} newValue\r\n     * @returns {String|MaskedInput|undefined}\r\n     */\r\n    _fieldValue(input, newValue) {\r\n        const $input = $(input);\r\n        if (!$input.length) return undefined;\r\n        input = $input[0];\r\n\r\n        const part = /**MaskedInput~Part=*/ $input.data('part');\r\n        let validatedValue;\r\n\r\n        if (newValue === undefined) {\r\n            let value = input.value;\r\n\r\n            // Predefined choices?\r\n            if (part.type === PartType.TEXT && part.options) {\r\n                return findMatchInArray(part.options, value, true, true, false);\r\n            }\r\n\r\n            // Enforce length\r\n            const maxLen = Math.max(part.length || 0, part.maxLength || 0);\r\n            if (maxLen > 0 && value.length > maxLen) {\r\n                value = value.substr(0, maxLen);\r\n            }\r\n\r\n            // Validate value\r\n            validatedValue = this._validateContent(value, part);\r\n            if (validatedValue === false) return undefined;\r\n\r\n            if (validatedValue !== true) { // A string, probably\r\n                value = validatedValue + '';\r\n            }\r\n\r\n            return value;\r\n        } else {\r\n            newValue = newValue == null ? '' : (newValue + '');\r\n            validatedValue = this._validateContent(newValue, part);\r\n            if (validatedValue === false) {\r\n                validatedValue = '';\r\n            } else if (validatedValue === true) {\r\n                validatedValue = newValue;\r\n            }\r\n\r\n            input.value = validatedValue;\r\n\r\n            this._syncInputSizeForPart(part);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieve an input element's value by index or label\r\n     * @public\r\n     * @param {Number|String} index\r\n     * @param {String?} newValue\r\n     * @returns {String|MaskedInput|undefined}\r\n     */\r\n    fieldValue(index, newValue) {\r\n        const p = this.p;\r\n\r\n        const input = p.inputs[index];\r\n\r\n        if (!input) return undefined;\r\n\r\n        if (newValue === undefined) {\r\n            return this._fieldValue(input);\r\n        } else {\r\n            this._fieldValue(input, newValue);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an option by name\r\n     * @param {String} name\r\n     * @param {*?} newValue\r\n     * @returns {MaskedInput}\r\n     */\r\n    option(name, newValue) {\r\n        const o = this.o;\r\n\r\n        if (arguments.length === 2) {\r\n            if (name === 'patterns') {\r\n                o[name] = {};\r\n\r\n                MaskedInput.patternAddons.forEach(addon => {\r\n                    o[name] = $.extend(o[name], addon);\r\n                });\r\n\r\n                o[name] = $.extend(o[name], newValue);\r\n            } else {\r\n                o[name] = newValue;\r\n            }\r\n        } else {\r\n            return o[name];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a part's option by option name\r\n     * @private\r\n     * @param {MaskedInput~Part} part\r\n     * @param {String|Object<String, *>} name\r\n     * @param {*?} value\r\n     * @returns {MaskedInput|*}\r\n     */\r\n    _fieldOption(part, name, value) {\r\n        const p = this.p;\r\n\r\n        if (!part) {\r\n            return arguments.length === 3 ? this : undefined;\r\n        }\r\n\r\n        if (arguments.length === 3 || typeof (name) === 'object') {\r\n\r\n            if (typeof name === 'object') {\r\n                // Set the options object for part\r\n                Object.keys(/**@type {Object<String, *>}*/name).forEach(key => {\r\n                    this._fieldOption(part, key, name[key]);\r\n                });\r\n\r\n                return this;\r\n            }\r\n\r\n            if (name === 'name' && part.name !== value) {\r\n\r\n                // Remove by the old name\r\n                if (parseInt(part.name, 10).toString() !== part.name &&\r\n                    p.inputs[part.name]) {\r\n                    if (p.inputs[part.name] instanceof HTMLElement) {\r\n                        delete p.inputs[part.name];\r\n                    } else {\r\n                        p.inputs[part.name].splice(p.inputs[part.name].indexOf(part), 1);\r\n                        if (p.inputs[part.name].length === 1) {\r\n                            p.inputs[part.name] = p.inputs[part.name][0];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Assign the new name\r\n                if (value && parseInt(value, 10).toString() !== value) {\r\n                    if (p.inputs[value]) {\r\n                        if (p.inputs[value] instanceof HTMLElement) {\r\n                            p.inputs[value] = [p.inputs[value], part];\r\n                        } else {\r\n                            p.inputs[value] = part;\r\n                        }\r\n                    } else {\r\n                        p.inputs[value] = part;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (name !== 'el' && name !== '$el') {\r\n                // Do not allow overriding the internal element pointer by mistake\r\n                part[name] = value;\r\n            }\r\n\r\n            if (part.el && (\r\n                name === 'length' ||\r\n                name === 'name' ||\r\n                name === 'ariaLabel' ||\r\n                name === 'placeholder')) {\r\n                this._renderInput(part, part.el);\r\n            }\r\n\r\n        } else {\r\n\r\n            if (Array.isArray(name)) {\r\n                // Return value mapping as an object\r\n                const options = {};\r\n\r\n                (/**@type String[]*/name).forEach(key => {\r\n                    options[key] = part[key];\r\n                });\r\n\r\n                return options;\r\n            } else {\r\n                // Return value\r\n                return part[name];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a part's option by part's index and option name\r\n     * @public\r\n     * @param {Number|String} index\r\n     * @param {String|Object} name\r\n     * @param {*?} value\r\n     * @returns {MaskedInput|*}\r\n     */\r\n    fieldOption(index, name, value) {\r\n        const that = this,\r\n            p = this.p;\r\n\r\n        const inputEls = p.inputs[index];\r\n        if (!inputEls) return this;\r\n\r\n        if (inputEls.length > 1) {\r\n            if (arguments.length === 3 || typeof (name) === 'object') {\r\n\r\n                // Set the option/options for all inputs\r\n                inputEls.forEach(el => {\r\n                    that._fieldOption($(el).data('part'), name, value);\r\n                });\r\n\r\n                delete p.valueRegex;\r\n\r\n                return this;\r\n            } else {\r\n\r\n                // Return array of option/options for all inputs\r\n                return inputEls.map(el => that._fieldOption($(el).data('part'), name));\r\n            }\r\n        } else {\r\n            if (arguments.length === 3) {\r\n\r\n                // Set the option/options for input\r\n                this._fieldOption($(inputEls).data('part'), name, value);\r\n\r\n                delete p.valueRegex;\r\n\r\n                return this;\r\n            } else {\r\n\r\n                // Return value/values\r\n                return this._fieldOption($(inputEls).data('part'), name);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get or set the full value\r\n     * @public\r\n     * @param {String?} newValue\r\n     * @returns {String|undefined|MaskedInput}\r\n     */\r\n    value(newValue) {\r\n        const p = this.p;\r\n\r\n        let pi, part, value;\r\n\r\n        if (newValue === undefined) {\r\n\r\n            let out = '';\r\n\r\n            for (pi = 0; pi < p.parsed.length; pi++) {\r\n                part = p.parsed[pi];\r\n\r\n                if (part.type === PartType.TEXT) {\r\n\r\n                    value = this._fieldValue(part.el);\r\n\r\n                    // Check that the value is OK\r\n                    if (part.postProcess) {\r\n                        value = part.postProcess.call(this, value, part) + '';\r\n                    }\r\n\r\n                    if (value === undefined) {\r\n                        if (part.required === undefined || part.required) {\r\n                            return undefined;\r\n                        }\r\n\r\n                        value = part.defaultValue || '';\r\n                    }\r\n\r\n                    out += value === undefined ? '' : value;\r\n\r\n                } else if (part.type === PartType.NUMBER) {\r\n\r\n                    value = this._fieldValue(part.el);\r\n\r\n                    // Check that the value is OK\r\n                    if (value === undefined) {\r\n                        if (part.required === undefined || part.required) {\r\n                            return undefined;\r\n                        }\r\n\r\n                        value = part.defaultValue || '';\r\n                    }\r\n\r\n                    // Post process\r\n                    if (part.postProcess) {\r\n                        value = part.postProcess.call(this, value, part);\r\n\r\n                        // Check again that the value is OK\r\n                        if (value === undefined) {\r\n                            if (part.required === undefined || part.required) {\r\n                                return undefined;\r\n                            }\r\n\r\n                            value = part.defaultValue || '';\r\n                        } else {\r\n                            value = value + '';\r\n                        }\r\n                    }\r\n\r\n                    const minLen = part.maxLength ?\r\n                        Math.max(0, Math.min(part.length || 0, part.maxLength || 0)) :\r\n                        (part.length || 0);\r\n                    const maxLen = Math.max(part.length || 0, part.maxLength || 0);\r\n\r\n                    // Try to pad with zeroes where possible\r\n                    if (part.padding || part.padding === undefined) {\r\n                        const padding = typeof part.padding === 'number' ? part.padding || minLen : minLen;\r\n\r\n                        if (padding > 0 && value.length < padding) {\r\n                            for (let i = 0; i < value.length; i++) {\r\n                                if (/[0-9.]/.test(value[i])) {\r\n                                    value = value.substr(0, i) +\r\n                                        repeatChar('0', padding - value.length) +\r\n                                        value.substr(i);\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            if (value.length < padding) {\r\n                                value = repeatChar('0', padding - value.length) + value;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    out += value === undefined ? '' : value;\r\n\r\n                } else { // PartType.LABEL\r\n                    // Probably a raw text between labels\r\n                    out += part.text;\r\n                }\r\n\r\n            }\r\n\r\n            return out;\r\n\r\n        } else {\r\n            if (!p.valueRegex) {\r\n                p.valueRegex = new RegExp(this._valuePattern(), 'i');\r\n            }\r\n\r\n            const matches = newValue.match(p.valueRegex) || [];\r\n            for (let i = 1, pi = 0; i < matches.length && pi < p.parsed.length; i++, pi++) {\r\n                part = p.parsed[pi];\r\n                value = matches[i] || '';\r\n\r\n                if (part.type !== PartType.LABEL) {\r\n\r\n                    this._fieldValue(part.el, value);\r\n\r\n                }\r\n\r\n            }\r\n\r\n            // Allow clearing the field\r\n            if (!matches.length && (newValue === '' || newValue === null)) {\r\n                for (pi = 0; pi < p.parsed.length; pi++) {\r\n                    part = p.parsed[pi];\r\n\r\n                    if (part.type !== PartType.LABEL) {\r\n                        this._fieldValue(part.el, '');\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns {function(string?):(String|MaskedInput|undefined)}\r\n     */\r\n    get val() {\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Set input enabled/disabled mode\r\n     * @param {Boolean} [enabled=true]\r\n     * @returns {MaskedInput} this\r\n     */\r\n    enable(enabled) {\r\n        const p = this.p;\r\n\r\n        enabled = !!enabled || enabled === undefined;\r\n\r\n        p.enabled = enabled;\r\n\r\n        this.$el.attr('disabled', enabled ? null : true);\r\n        this.$el.find('input').prop('disabled', !enabled);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set input enabled/disabled mode\r\n     * @param {Boolean} [disabled=true]\r\n     * @returns {MaskedInput} this\r\n     */\r\n    disable(disabled) {\r\n        disabled = !!disabled || disabled === undefined;\r\n        return this.enable(!disabled);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns {Boolean} <code>true</code> if enabled\r\n     */\r\n    get isEnabled() {\r\n        return this.p.enabled;\r\n    }\r\n\r\n    /**\r\n     * Set input enabled/disabled mode\r\n     * @param {Boolean} enabled\r\n     */\r\n    set isEnabled(enabled) {\r\n        this.enable(enabled);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns {Boolean} <code>true</code> if disabled\r\n     */\r\n    get isDisabled() {\r\n        return !this.p.enabled;\r\n    }\r\n\r\n    /**\r\n     * Set input enabled/disabled mode\r\n     * @param {Boolean} disabled\r\n     */\r\n    set isDisabled(disabled) {\r\n        this.disable(disabled);\r\n    }\r\n}\r\n\r\nconst FORMAT_REGEX = new RegExp(\r\n    '(0+(?::[a-zA-Z0-9_]+)?)' + /* numeric value, fixed length, with possible :name_123 */\r\n    '|(#+(?::[a-zA-Z0-9_]+)?)' + /* numeric value, with possible :name_123 */\r\n    '|((?:@+|\\\\*)(?::[a-zA-Z0-9_]+)?)' + /* text value with maximum or variable length, with possible :name_123 */\r\n    '|(\"[^\"]*\"|\\'[^\\']*\\')' /* possible quoted text */\r\n    , 'g', // find all matches\r\n);\r\n\r\n/**\r\n * @public\r\n * @expose\r\n */\r\nMaskedInput.PartType = PartType;\r\n\r\n/**\r\n * Here we can add more pattern addons\r\n * @public\r\n * @expose\r\n */\r\nMaskedInput.patternAddons = [];\r\n\r\n/**\r\n * Default options for the control\r\n * @public\r\n * @expose\r\n * @type {MaskedInput.Options}\r\n */\r\nMaskedInput.defaults = defaults;\r\n\r\nexport default MaskedInput;\r\n","'use strict';\r\n\r\nimport MaskedInput from './jquery.maskedinput.core';\r\n\r\n/**\r\n * @name MaskedInput~Options\r\n * @property {MaskedInput~DateLocale} [dateLocale] - Date localization map\r\n */\r\n\r\n/**\r\n * @typedef {Object} MaskedInput~DateLocale\r\n * @property {String[]} [MMM]\r\n * @property {String[]} [MMMM]\r\n * @property {String[]} [t]\r\n * @property {String[]} [tt]\r\n * @property {String[]} [T]\r\n * @property {String[]} [TT]\r\n */\r\n\r\nconst repeatChar = function (char, length) {\r\n    let out = '';\r\n    for (let i = 0; i < length; i++) {\r\n        out += char;\r\n    }\r\n    return out;\r\n};\r\n\r\nconst maxArrayStringLength = function (array) {\r\n    let slen = 0;\r\n    for (let i = 0; i < array.length; i++) {\r\n        if (array[i].length > slen) {\r\n            slen = array[i].length;\r\n        }\r\n    }\r\n    return slen;\r\n};\r\n\r\n//noinspection UnnecessaryLocalVariableJS\r\nconst EnglishDateLocale = /** @type {MaskedInput~DateLocale} */ {\r\n    MMM: [\r\n        'Jan', 'Feb', 'Mar',\r\n        'Apr', 'May', 'Jun',\r\n        'Jul', 'Aug', 'Sep',\r\n        'Oct', 'Nov', 'Dec',\r\n    ],\r\n    MMMM: [\r\n        'January', 'February', 'March',\r\n        'April', 'May', 'June',\r\n        'July', 'August', 'September',\r\n        'October', 'November', 'December',\r\n    ],\r\n    t: ['a', 'p'],\r\n    tt: ['am', 'pm'],\r\n    T: ['A', 'P'],\r\n    TT: ['AM', 'PM'],\r\n    aria: {\r\n        day: 'Day',\r\n        month: 'Month',\r\n        year: 'Year',\r\n        hour: 'Hour',\r\n        minutes: 'Minutes',\r\n        seconds: 'Seconds',\r\n        ampm: 'Am/Pm',\r\n    },\r\n};\r\n\r\nMaskedInput.defaults.dateLocale = EnglishDateLocale;\r\n\r\nconst DATE_PATTERN_MAP = {\r\n    // d - 1-31\r\n    // dd - 01-31\r\n    dd: {\r\n        pattern: /\\bdd?\\b/,\r\n        type: MaskedInput.PartType.NUMBER,\r\n        name: 'day',\r\n        maxLength: 2,\r\n        placeholder: function (match) {\r\n            return repeatChar('d', match.length);\r\n        },\r\n        numericMin: 0, // Allow typing in zeroes, like 06\r\n        numericMax: 31,\r\n        wholeNumber: true,\r\n        padding: function (match) {\r\n            return match.length;\r\n        },\r\n        postProcess: function (value) {\r\n            value = parseInt(value);\r\n            if (value < 1 || value > 31) return undefined;\r\n            return value + '';\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).day;\r\n        },\r\n    },\r\n    MM: {\r\n        // M - 1-12\r\n        // MM - 01-12\r\n        pattern: /\\bMM?\\b/,\r\n        type: MaskedInput.PartType.NUMBER,\r\n        name: 'month',\r\n        maxLength: 2,\r\n        placeholder: function (match) {\r\n            return repeatChar('m', match.length);\r\n        },\r\n        numericMin: 0, // Allow typing in zeroes, like 06\r\n        numericMax: 12,\r\n        wholeNumber: true,\r\n        padding: function (match) {\r\n            return match.length;\r\n        },\r\n        postProcess: function (value) {\r\n            value = parseInt(value);\r\n            if (value < 1 || value > 12) return undefined;\r\n            return value + '';\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).month;\r\n        },\r\n    },\r\n    MMM: {\r\n        // MMM - Jan-Dec\r\n        pattern: /\\bMMM\\b/,\r\n        type: MaskedInput.PartType.TEXT,\r\n        name: 'month',\r\n        placeholder: function (match) {\r\n            return repeatChar('m', match.length);\r\n        },\r\n        length: function (match) {\r\n            return maxArrayStringLength(this.option('dateLocale')[match]);\r\n        },\r\n        options: function (match) {\r\n            return this.option('dateLocale')[match];\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).month;\r\n        },\r\n    },\r\n    MMMM: {\r\n        // MMMM - January-December\r\n        pattern: /\\bMMMM\\b/,\r\n        type: MaskedInput.PartType.TEXT,\r\n        name: 'month',\r\n        placeholder: function (match) {\r\n            return repeatChar('m', match.length);\r\n        },\r\n        length: function (match) {\r\n            return maxArrayStringLength(this.option('dateLocale')[match]);\r\n        },\r\n        options: function (match) {\r\n            return this.option('dateLocale')[match];\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).month;\r\n        },\r\n    },\r\n    yyyy: {\r\n        // yy - 85\r\n        // yyyy - 1985\r\n        pattern: /\\byy(?:yy)?\\b/,\r\n        type: MaskedInput.PartType.NUMBER,\r\n        name: 'year',\r\n        wholeNumber: true,\r\n        placeholder: function (match) {\r\n            return repeatChar('y', match.length);\r\n        },\r\n        maxLength: function (match) {\r\n            return match.length;\r\n        },\r\n        postProcess: function (value, part) {\r\n\r\n            if (part.maxLength === 4) {\r\n                const baseYear = Math.floor((new Date()).getFullYear() / 100) * 100;\r\n                const nowYear = new Date().getFullYear();\r\n\r\n                let year = parseInt(value, 10);\r\n\r\n                if (year < 100) {\r\n                    year += baseYear;\r\n                    if (year - nowYear > 50) {\r\n                        year -= 100;\r\n                    } else if (nowYear - year > 50) {\r\n                        year += 100;\r\n                    }\r\n                }\r\n\r\n                return year + '';\r\n            } else {\r\n\r\n                return value;\r\n            }\r\n        },\r\n        padding: function (match) {\r\n            return match.length;\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).year;\r\n        },\r\n    },\r\n    HH: {\r\n        // H - 0-24\r\n        // HH - 00-24\r\n        pattern: /\\bHH?\\b/,\r\n        type: MaskedInput.PartType.NUMBER,\r\n        name: 'hours',\r\n        maxLength: 2,\r\n        placeholder: function (match) {\r\n            return repeatChar('h', match.length);\r\n        },\r\n        numericMin: 0,\r\n        numericMax: 23,\r\n        wholeNumber: true,\r\n        padding: function (match) {\r\n            return match.length;\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).hour;\r\n        },\r\n    },\r\n    hh: {\r\n        // h - 1-12\r\n        // hh - 01-12\r\n        pattern: /\\bhh?\\b/,\r\n        type: MaskedInput.PartType.NUMBER,\r\n        name: 'hours_12',\r\n        maxLength: 2,\r\n        placeholder: function (match) {\r\n            return repeatChar('h', match.length);\r\n        },\r\n        numericMin: 1,\r\n        numericMax: 12,\r\n        wholeNumber: true,\r\n        padding: function (match) {\r\n            return match.length;\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).hour;\r\n        },\r\n    },\r\n    mm: {\r\n        // m - 0-59\r\n        // mm - 00-59\r\n        pattern: /\\bmm?\\b/,\r\n        type: MaskedInput.PartType.NUMBER,\r\n        name: 'minutes',\r\n        maxLength: 2,\r\n        placeholder: function (match) {\r\n            return repeatChar('m', match.length);\r\n        },\r\n        numericMin: 0,\r\n        numericMax: 59,\r\n        wholeNumber: true,\r\n        padding: function (match) {\r\n            return match.length;\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).minutes;\r\n        },\r\n    },\r\n    ss: {\r\n        // s - 0-59\r\n        // ss - 00-59\r\n        pattern: /\\bss?\\b/,\r\n        type: MaskedInput.PartType.NUMBER,\r\n        name: 'seconds',\r\n        maxLength: 2,\r\n        placeholder: function (match) {\r\n            return repeatChar('s', match.length);\r\n        },\r\n        numericMin: 0,\r\n        numericMax: 59,\r\n        wholeNumber: true,\r\n        padding: function (match) {\r\n            return match.length;\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).seconds;\r\n        },\r\n    },\r\n    tt: {\r\n        // t - a/p\r\n        // tt - am/pm\r\n        // T - A/P\r\n        // TT - AM/PM\r\n        pattern: /\\btt?|TT?\\b/,\r\n        type: MaskedInput.PartType.TEXT,\r\n        name: 'ampm',\r\n        length: function (match) {\r\n            return maxArrayStringLength(this.option('dateLocale')[match]);\r\n        },\r\n        options: function (match) {\r\n            return this.option('dateLocale')[match];\r\n        },\r\n        defaultValue: function (match) {\r\n            return this.option('dateLocale')[match][0];\r\n        },\r\n        ariaLabel: function (_match) {\r\n            return (this.option('dateLocale').aria || {}).ampm;\r\n        },\r\n    },\r\n};\r\n\r\nMaskedInput.patternAddons.push(DATE_PATTERN_MAP);\r\n\r\nexport default MaskedInput;\r\n"],"names":["PartType","NUMBER","TEXT","LABEL","execRegexWithLeftovers","regex","input","onMatch","onLeftover","match","lastIndex","exec","index","substring","length","getSelectionRange","el","begin","end","direction","setSelectionRange","selectionStart","selectionEnd","selectionDirection","document","selection","createRange","range","duplicate","moveStart","text","repeatChar","char","out","i","findMatchInArray","options","term","closestChoice","returnFullMatch","caseSensitive","option","optionLower","termLower","toLowerCase","maxMatchOption","maxMatchFullOption","maxMatchLength","clen","Math","min","substr","escapeRegExp","str","replace","callFunctor","functor","bind","_arg1","apply","Array","prototype","slice","call","arguments","inputBackbufferCssProps","hasComputedStyle","defaultView","getComputedStyle","getPreciseContentWidth","style","currentStyle","width","parseFloat","FOCUSABLES","FOCUSABLE_SELECTOR","join","TABBABLE_SELECTOR","map","x","MaskedInput","constructor","o","this","$","extend","defaults","patterns","patternAddons","forEach","addon","p","enabled","inputs","$el","addClass","className","data","parsed","_parseFormat","format","$inputBackBuffer","on","event","target","currentTarget","is","offset","left","offsetX","top","offsetY","elements","y","bestMatch","minDistance","elOffset","right","outerWidth","bottom","outerHeight","offsets","dx","dy","distance","sqrt","closestToOffset","children","focus","render","setTimeout","parentNode","resize","parsedFormat","FORMAT_REGEX","numericMatch","textMatch","quotedMatch","part","type","indexOf","name","maxLength","push","labelText","leftover","leftoverParts","Object","keys","key","RegExp","pattern","source","flags","fpos","fpart","newParts","validator","ignored","ariaLabel","placeholder","numericMin","numericMax","wholeNumber","postProcess","padding","required","defaultValue","forcePlaceholderWidth","splice","concat","empty","_renderText","appendTo","$input","_renderInput","parseInt","toString","isNewInput","prop","setAttribute","removeAttribute","undefined","_handleInput","_syncInputSizeForPart","_handleKeydown","_handleKeypress","_syncInputSize","alwaysConsiderPlaceholder","fallbackText","$backBuffer","inputEl","value","css","backBufferWidth","currentWidth","max","scrollWidth","remove","content","validatedContent","_validateContent","preventDefault","trigger","_shouldMoveToNextFieldAfterInput","nextAll","first","readOnly","keycode","which","triggerChange","contentBefore","nextValue","tryToUpdate","minLen","maxLen","fullMatch","round","Infinity","isRtl","prevAll","pos","ctrlKey","altKey","metaKey","moveToNextField","pressedChar","String","fromCharCode","contentAfter","newPos","createTextRange","collapse","moveEnd","select","newContent","test","ret","parsedValue","isNaN","field","isArray","_valuePattern","group","_fieldValue","newValue","validatedValue","fieldValue","_fieldOption","HTMLElement","fieldOption","that","inputEls","valueRegex","pi","matches","enable","attr","find","disable","disabled","maxArrayStringLength","array","slen","dateLocale","MMM","MMMM","t","tt","T","TT","aria","day","month","year","hour","minutes","seconds","ampm","DATE_PATTERN_MAP","dd","_match","MM","yyyy","baseYear","floor","Date","getFullYear","nowYear","HH","hh","mm","ss"],"mappings":"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"}